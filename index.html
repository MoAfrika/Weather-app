<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Aurora Weather OS</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@200;300;400;500;600;700;800&display=swap" rel="stylesheet">
    
    <!-- Icons (Lucide) - Explicit UMD Build -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['"Plus Jakarta Sans"', 'sans-serif'],
                    },
                    colors: {
                        glass: 'rgba(255, 255, 255, 0.08)',
                        glassBorder: 'rgba(255, 255, 255, 0.12)',
                        glassHigh: 'rgba(255, 255, 255, 0.15)',
                    },
                    animation: {
                        'float': 'float 6s ease-in-out infinite',
                        'pulse-slow': 'pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'slide-up': 'slideUp 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards',
                    },
                    keyframes: {
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' },
                        },
                        slideUp: {
                            '0%': { transform: 'translateY(20px)', opacity: '0' },
                            '100%': { transform: 'translateY(0)', opacity: '1' },
                        }
                    }
                }
            }
        }
    </script>

    <style>
        /* Global Reset & Base */
        body {
            background-color: #0f172a;
            color: #ffffff;
            overflow: hidden; /* App-like feel */
        }

        /* Dynamic Gradients based on Weather */
        .bg-gradient-clear { background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%); }
        .bg-gradient-cloudy { background: linear-gradient(135deg, #64748b 0%, #475569 100%); }
        .bg-gradient-rain { background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); }
        .bg-gradient-hot { background: linear-gradient(135deg, #f59e0b 0%, #ef4444 100%); }
        .bg-gradient-night { background: linear-gradient(135deg, #020617 0%, #1e1b4b 100%); }

        /* Glassmorphism Cards */
        .glass-card {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.2);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        
        .glass-card:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        /* Custom Scrollbar */
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        /* Weather Canvas */
        #weather-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 0;
            opacity: 0.6;
        }

        /* Typography & Utilities */
        .text-shadow-sm { text-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .text-shadow-lg { text-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        
        /* Input Reset */
        input:focus { outline: none; }
        
        /* Loading Skeleton Animation */
        .skeleton {
            background: linear-gradient(90deg, rgba(255,255,255,0.05) 25%, rgba(255,255,255,0.1) 50%, rgba(255,255,255,0.05) 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
        }
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
    </style>
</head>
<body class="relative h-screen w-screen flex items-center justify-center bg-gray-900 transition-colors duration-1000 ease-in-out" id="app-body">

    <!-- Ambient Canvas Layer -->
    <canvas id="weather-canvas"></canvas>

    <!-- App Container (Mobile Aspect Ratio Preserved on Desktop) -->
    <div class="relative w-full h-full md:max-w-[420px] md:h-[90vh] md:rounded-[40px] md:border md:border-white/10 overflow-hidden flex flex-col z-10 shadow-2xl bg-black/20 backdrop-blur-sm">
        
        <!-- Header / Search -->
        <header class="flex-none px-6 pt-12 pb-4 flex justify-between items-center z-20">
            <div class="flex flex-col cursor-pointer group" onclick="toggleSearch()">
                <div class="flex items-center gap-2">
                    <i data-lucide="map-pin" class="w-4 h-4 text-white/70 group-hover:text-white transition-colors"></i>
                    <h1 id="city-name" class="text-xl font-bold tracking-tight text-shadow-sm">Locating...</h1>
                </div>
                <p id="current-date" class="text-xs text-white/50 font-medium pl-6">Updating...</p>
            </div>
            <button onclick="toggleSearch()" class="w-10 h-10 rounded-full glass-card flex items-center justify-center text-white/80 hover:text-white hover:bg-white/10 active:scale-95 transition-all">
                <i data-lucide="search" class="w-5 h-5"></i>
            </button>
        </header>

        <!-- Search Overlay -->
        <div id="search-overlay" class="absolute inset-0 bg-black/60 backdrop-blur-xl z-50 transform translate-y-full transition-transform duration-300 flex flex-col p-6">
            <div class="flex justify-end mb-8">
                <button onclick="toggleSearch()" class="p-2 rounded-full bg-white/10 hover:bg-white/20">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            <h2 class="text-2xl font-bold mb-4">Find City</h2>
            <form onsubmit="handleSearch(event)" class="relative">
                <input type="text" id="search-input" placeholder="Search global..." class="w-full bg-white/10 border border-white/10 rounded-2xl px-5 py-4 text-lg text-white placeholder-white/30 focus:border-white/30 focus:bg-white/15 transition-all">
                <button type="submit" class="absolute right-4 top-1/2 -translate-y-1/2 bg-blue-500 p-2 rounded-xl text-white shadow-lg shadow-blue-500/30">
                    <i data-lucide="arrow-right" class="w-5 h-5"></i>
                </button>
            </form>
            <div id="recent-searches" class="mt-8 flex flex-col gap-2">
                <!-- Recent searches populated by JS -->
            </div>
        </div>

        <!-- Main Scrollable Content -->
        <main class="flex-1 overflow-y-auto overflow-x-hidden hide-scrollbar pb-10 px-6 relative space-y-6">
            
            <!-- Hero Section -->
            <section class="flex flex-col items-center justify-center pt-2 pb-6 animate-slide-up" style="animation-delay: 0.1s;">
                <div class="relative w-48 h-48 flex items-center justify-center">
                    <!-- Glow effect -->
                    <div class="absolute inset-0 bg-white/20 rounded-full blur-[60px] opacity-40 animate-pulse-slow"></div>
                    <img id="weather-icon" src="" alt="Weather" class="w-40 h-40 object-contain drop-shadow-2xl animate-float relative z-10 filter drop-shadow-[0_10px_20px_rgba(0,0,0,0.3)]">
                </div>
                
                <div class="flex flex-col items-center -mt-4">
                    <h1 class="text-[6.5rem] font-bold leading-none tracking-tighter text-transparent bg-clip-text bg-gradient-to-b from-white to-white/60 drop-shadow-lg" id="temp-display">--°</h1>
                    <p id="condition-display" class="text-xl font-medium text-white/90 capitalize tracking-wide mt-2 px-4 py-1 rounded-full glass-card border-none bg-white/5">Loading...</p>
                </div>

                <div class="flex gap-6 mt-6 text-sm font-medium text-white/60">
                    <span class="flex items-center gap-1"><i data-lucide="arrow-up" class="w-3 h-3"></i> <span id="temp-max">--</span>°</span>
                    <span class="flex items-center gap-1"><i data-lucide="arrow-down" class="w-3 h-3"></i> <span id="temp-min">--</span>°</span>
                    <span class="flex items-center gap-1"><i data-lucide="wind" class="w-3 h-3"></i> <span id="wind-speed">--</span> km/h</span>
                </div>
            </section>

            <!-- AI Insight (Simulated) -->
            <section class="glass-card rounded-3xl p-5 animate-slide-up relative overflow-hidden group" style="animation-delay: 0.2s;">
                <div class="absolute -right-4 -top-4 w-20 h-20 bg-purple-500/30 rounded-full blur-2xl group-hover:bg-purple-500/50 transition-all duration-500"></div>
                <div class="flex items-start gap-3 relative z-10">
                    <div class="w-8 h-8 rounded-full bg-gradient-to-br from-indigo-400 to-purple-500 flex items-center justify-center shadow-lg shadow-purple-500/30">
                        <i data-lucide="sparkles" class="w-4 h-4 text-white"></i>
                    </div>
                    <div class="flex-1">
                        <h3 class="text-xs font-bold text-purple-200 uppercase tracking-wider mb-1">Aurora AI Insight</h3>
                        <p id="ai-text" class="text-sm leading-relaxed text-white/90 font-light">Analyzing atmospheric patterns...</p>
                    </div>
                </div>
            </section>

            <!-- Hourly Forecast (Graph + Scroll) -->
            <section class="glass-card rounded-3xl p-5 animate-slide-up" style="animation-delay: 0.3s;">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-sm font-semibold text-white/70 flex items-center gap-2">
                        <i data-lucide="clock" class="w-4 h-4"></i> Hourly
                    </h3>
                    <span class="text-xs text-white/40">24h Trend</span>
                </div>
                
                <!-- SVG Graph Container -->
                <div class="h-[80px] w-full relative mb-4">
                    <svg id="temp-graph" class="w-full h-full overflow-visible" preserveAspectRatio="none">
                        <!-- Path injected by JS -->
                    </svg>
                </div>

                <!-- Scrollable Times -->
                <div id="hourly-scroll" class="flex gap-4 overflow-x-auto hide-scrollbar pb-2">
                    <!-- Injected by JS -->
                </div>
            </section>

            <!-- Bento Grid Stats -->
            <section class="grid grid-cols-2 gap-4 animate-slide-up" style="animation-delay: 0.4s;">
                <!-- UV Index -->
                <div class="glass-card rounded-3xl p-4 flex flex-col justify-between aspect-[4/3] relative overflow-hidden">
                    <div class="absolute right-0 bottom-0 w-16 h-16 bg-yellow-500/20 rounded-full blur-xl"></div>
                    <div class="flex items-center gap-2 text-white/60 mb-2">
                        <i data-lucide="sun" class="w-4 h-4"></i>
                        <span class="text-xs font-semibold uppercase">UV Index</span>
                    </div>
                    <div>
                        <span id="uv-val" class="text-3xl font-bold">--</span>
                        <p id="uv-text" class="text-xs text-white/60 mt-1">Moderate</p>
                    </div>
                    <!-- Progress Bar -->
                    <div class="w-full h-1 bg-white/10 rounded-full mt-2 overflow-hidden">
                        <div id="uv-bar" class="h-full bg-gradient-to-r from-green-400 to-red-500 w-0 transition-all duration-1000"></div>
                    </div>
                </div>

                <!-- Humidity -->
                <div class="glass-card rounded-3xl p-4 flex flex-col justify-between aspect-[4/3] relative overflow-hidden">
                    <div class="absolute right-0 bottom-0 w-16 h-16 bg-blue-500/20 rounded-full blur-xl"></div>
                    <div class="flex items-center gap-2 text-white/60 mb-2">
                        <i data-lucide="droplets" class="w-4 h-4"></i>
                        <span class="text-xs font-semibold uppercase">Humidity</span>
                    </div>
                    <div>
                        <span id="humidity-val" class="text-3xl font-bold">--%</span>
                        <p id="dew-point" class="text-xs text-white/60 mt-1">Dew point: --°</p>
                    </div>
                </div>

                <!-- Sunrise/Sunset -->
                <div class="glass-card rounded-3xl p-4 flex flex-col justify-between col-span-2 relative overflow-hidden">
                    <div class="flex items-center justify-between mb-2">
                         <div class="flex items-center gap-2 text-white/60">
                            <i data-lucide="horizon" class="w-4 h-4"></i>
                            <span class="text-xs font-semibold uppercase">Sun Path</span>
                        </div>
                    </div>
                    <div class="flex justify-between items-end relative h-16 w-full">
                        <!-- Arc drawn by CSS/SVG -->
                         <svg class="absolute bottom-0 left-0 w-full h-full" viewBox="0 0 200 80" preserveAspectRatio="none">
                            <path d="M10,80 Q100,10 190,80" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="2" stroke-dasharray="4 4" />
                            <circle id="sun-position" cx="10" cy="80" r="6" fill="#fbbf24" class="shadow-[0_0_10px_#fbbf24]" />
                         </svg>
                         <div class="flex flex-col z-10">
                            <span class="text-xs text-white/50">Rise</span>
                            <span id="sunrise-val" class="text-sm font-bold">--:--</span>
                         </div>
                         <div class="flex flex-col items-end z-10">
                            <span class="text-xs text-white/50">Set</span>
                            <span id="sunset-val" class="text-sm font-bold">--:--</span>
                         </div>
                    </div>
                </div>
            </section>

            <!-- 7-Day Forecast -->
            <section class="glass-card rounded-3xl p-5 animate-slide-up mb-8" style="animation-delay: 0.5s;">
                 <h3 class="text-sm font-semibold text-white/70 mb-4 flex items-center gap-2">
                    <i data-lucide="calendar-days" class="w-4 h-4"></i> 7-Day Forecast
                </h3>
                <div id="daily-container" class="space-y-4">
                    <!-- Injected by JS -->
                </div>
            </section>

            <footer class="text-center text-xs text-white/30 pb-4">
                Powered by Open-Meteo & Gemini Logic
            </footer>

        </main>
    </div>

    <!-- Scripts -->
    <script>
        // --- CONFIG & STATE ---
        const state = {
            lat: -25.7449, // Default: Pretoria
            lon: 28.1879,
            city: "Pretoria",
            units: "metric", // metric or imperial
            weatherData: null,
            geoData: null
        };

        // DOM Elements
        const els = {
            body: document.getElementById('app-body'),
            city: document.getElementById('city-name'),
            date: document.getElementById('current-date'),
            temp: document.getElementById('temp-display'),
            condition: document.getElementById('condition-display'),
            icon: document.getElementById('weather-icon'),
            tempMax: document.getElementById('temp-max'),
            tempMin: document.getElementById('temp-min'),
            wind: document.getElementById('wind-speed'),
            aiText: document.getElementById('ai-text'),
            hourlyScroll: document.getElementById('hourly-scroll'),
            graph: document.getElementById('temp-graph'),
            dailyContainer: document.getElementById('daily-container'),
            uvVal: document.getElementById('uv-val'),
            uvText: document.getElementById('uv-text'),
            uvBar: document.getElementById('uv-bar'),
            humidity: document.getElementById('humidity-val'),
            dewPoint: document.getElementById('dew-point'),
            sunrise: document.getElementById('sunrise-val'),
            sunset: document.getElementById('sunset-val'),
            searchOverlay: document.getElementById('search-overlay'),
            searchInput: document.getElementById('search-input'),
            sunPos: document.getElementById('sun-position')
        };

        // --- PARTICLE SYSTEM (Canvas) ---
        const canvas = document.getElementById('weather-canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];
        let animationId;
        let weatherType = 'clear'; // clear, rain, snow, cloudy

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        class Particle {
            constructor(type) {
                this.type = type;
                this.reset();
            }

            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height - canvas.height;
                
                if (this.type === 'rain') {
                    this.vy = Math.random() * 5 + 10;
                    this.vx = (Math.random() - 0.5) * 1;
                    this.len = Math.random() * 10 + 10;
                    this.color = `rgba(200, 220, 255, ${Math.random() * 0.2 + 0.1})`;
                } else if (this.type === 'snow') {
                    this.vy = Math.random() * 2 + 1;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.size = Math.random() * 3 + 1;
                    this.color = `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.3})`;
                } else if (this.type === 'cloud') {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * (canvas.height / 2); // Top half
                    this.vx = (Math.random() - 0.5) * 0.5;
                    this.vy = 0;
                    this.size = Math.random() * 100 + 50;
                    this.color = `rgba(255, 255, 255, ${Math.random() * 0.05})`;
                }
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.type === 'rain' || this.type === 'snow') {
                    if (this.y > canvas.height) this.reset();
                } else if (this.type === 'cloud') {
                    if (this.x > canvas.width + 100) this.x = -100;
                    if (this.x < -100) this.x = canvas.width + 100;
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.color;

                if (this.type === 'rain') {
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x + this.vx, this.y + this.len);
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else if (this.type === 'snow') {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'cloud') {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function initParticles(type) {
            weatherType = type;
            particles = [];
            const count = type === 'rain' ? 200 : type === 'snow' ? 100 : type === 'cloud' ? 20 : 0;
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(type));
            }
        }

        function animateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach(p => {
                p.update();
                p.draw();
            });
            animationId = requestAnimationFrame(animateParticles);
        }

        // --- WEATHER LOGIC ---

        const wmoCodes = {
            0: { desc: "Clear Sky", icon: "sun", type: "clear", theme: "bg-gradient-clear" },
            1: { desc: "Mainly Clear", icon: "sun-dim", type: "clear", theme: "bg-gradient-clear" },
            2: { desc: "Partly Cloudy", icon: "cloud-sun", type: "cloud", theme: "bg-gradient-cloudy" },
            3: { desc: "Overcast", icon: "cloud", type: "cloud", theme: "bg-gradient-cloudy" },
            45: { desc: "Fog", icon: "cloud-fog", type: "cloud", theme: "bg-gradient-night" },
            48: { desc: "Depositing Rime Fog", icon: "cloud-fog", type: "cloud", theme: "bg-gradient-night" },
            51: { desc: "Light Drizzle", icon: "cloud-drizzle", type: "rain", theme: "bg-gradient-rain" },
            53: { desc: "Moderate Drizzle", icon: "cloud-drizzle", type: "rain", theme: "bg-gradient-rain" },
            55: { desc: "Dense Drizzle", icon: "cloud-rain", type: "rain", theme: "bg-gradient-rain" },
            61: { desc: "Slight Rain", icon: "cloud-rain", type: "rain", theme: "bg-gradient-rain" },
            63: { desc: "Moderate Rain", icon: "cloud-rain", type: "rain", theme: "bg-gradient-rain" },
            65: { desc: "Heavy Rain", icon: "cloud-lightning", type: "rain", theme: "bg-gradient-rain" },
            71: { desc: "Slight Snow", icon: "snowflake", type: "snow", theme: "bg-gradient-cloudy" },
            73: { desc: "Moderate Snow", icon: "snowflake", type: "snow", theme: "bg-gradient-cloudy" },
            75: { desc: "Heavy Snow", icon: "snowflake", type: "snow", theme: "bg-gradient-cloudy" },
            95: { desc: "Thunderstorm", icon: "zap", type: "rain", theme: "bg-gradient-night" }
        };

        function getWmoInfo(code) {
            return wmoCodes[code] || wmoCodes[0];
        }

        // Helper: Date Formatting
        function formatTime(isoString) {
            return new Date(isoString).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }
        function getDayName(isoString) {
            return new Date(isoString).toLocaleDateString([], { weekday: 'short' });
        }

        // --- AI LOGIC (Client-Side Heuristics) ---
        function generateAuroraInsight(current, daily, codeInfo) {
            const temp = current.temperature_2m;
            const wind = current.wind_speed_10m;
            const desc = codeInfo.desc.toLowerCase();
            const isNight = current.is_day === 0;

            const insights = [
                { cond: temp > 30, text: "It's officially 'melting pavement' weather. Hydrate or evaporate." },
                { cond: temp < 5, text: "Brass monkeys are worried. Wear layers upon layers." },
                { cond: desc.includes("rain"), text: "Free car wash today. Don't forget the umbrella." },
                { cond: desc.includes("thunder"), text: "Thor is bowling. Stay inside and charge your phone." },
                { cond: desc.includes("clear") && isNight, text: "Perfect stargazing conditions. Look up, not down at your phone." },
                { cond: desc.includes("clear") && !isNight, text: "Solar power optimum. Go photosynthesize." },
                { cond: wind > 20, text: "Hold onto your hat. Literally. It's windy." },
                { cond: true, text: `Current mood: ${desc}. Temperature: reasonable.` } // Default
            ];

            return insights.find(i => i.cond).text;
        }

        // --- API & DATA HANDLING ---

        async function fetchWeather() {
            els.condition.innerText = "Scanning skies...";
            
            try {
                // Fetch Geo info for exact name if not set
                const params = new URLSearchParams({
                    latitude: state.lat,
                    longitude: state.lon,
                    current: "temperature_2m,relative_humidity_2m,is_day,weather_code,wind_speed_10m,pressure_msl",
                    hourly: "temperature_2m,weather_code,visibility",
                    daily: "weather_code,temperature_2m_max,temperature_2m_min,sunrise,sunset,uv_index_max",
                    timezone: "auto"
                });

                const res = await fetch(`https://api.open-meteo.com/v1/forecast?${params}`);
                if (!res.ok) throw new Error("Weather data unreachable");
                const data = await res.json();
                
                state.weatherData = data;
                updateUI(data);

            } catch (error) {
                console.error(error);
                els.condition.innerText = "Connection lost.";
                alert("Failed to fetch weather data. Please try again.");
            }
        }

        function updateUI(data) {
            const current = data.current;
            const daily = data.daily;
            const hourly = data.hourly;
            const wmo = getWmoInfo(current.weather_code);

            // 1. Theme & Background
            els.body.className = `relative h-screen w-screen flex items-center justify-center transition-colors duration-1000 ease-in-out ${wmo.theme}`;
            if(current.is_day === 0) els.body.className = `relative h-screen w-screen flex items-center justify-center transition-colors duration-1000 ease-in-out bg-gradient-night`;
            
            // Particles
            initParticles(wmo.type);
            if (!animationId) animateParticles();

            // 2. Hero Section
            els.city.innerText = state.city;
            els.date.innerText = new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });
            els.temp.innerText = `${Math.round(current.temperature_2m)}°`;
            els.condition.innerText = wmo.desc;
            els.tempMax.innerText = Math.round(daily.temperature_2m_max[0]);
            els.tempMin.innerText = Math.round(daily.temperature_2m_min[0]);
            els.wind.innerText = Math.round(current.wind_speed_10m);

            // Dynamic Icon (Lucide doesn't have huge colored icons, so we use an external set or styles)
            // For slickness, we will use a high-quality external image source based on code
            // Fallback to a clean set
            const iconMap = {
                'clear': 'https://cdn-icons-png.flaticon.com/512/869/869869.png', // Sun
                'cloud': 'https://cdn-icons-png.flaticon.com/512/1146/1146869.png', // Cloud
                'rain': 'https://cdn-icons-png.flaticon.com/512/1163/1163657.png', // Rain
                'snow': 'https://cdn-icons-png.flaticon.com/512/642/642000.png', // Snow
                'night': 'https://cdn-icons-png.flaticon.com/512/592/592317.png' // Moon
            };
            
            let iconUrl = iconMap[wmo.type];
            if (current.is_day === 0 && wmo.type === 'clear') iconUrl = iconMap['night'];
            els.icon.src = iconUrl;


            // 3. AI Insight
            els.aiText.innerText = generateAuroraInsight(current, daily, wmo);

            // 4. Hourly Graph & Scroll
            renderHourly(hourly, current.time);

            // 5. Bento Stats
            const uv = daily.uv_index_max[0];
            els.uvVal.innerText = uv;
            els.uvText.innerText = uv < 3 ? "Low" : uv < 6 ? "Moderate" : uv < 8 ? "High" : "Very High";
            els.uvBar.style.width = `${Math.min((uv / 11) * 100, 100)}%`;
            
            els.humidity.innerText = `${current.relative_humidity_2m}%`;
            // Calculate pseudo dew point
            const dew = Math.round(current.temperature_2m - ((100 - current.relative_humidity_2m) / 5));
            els.dewPoint.innerText = `Dew Point: ${dew}°`;

            els.sunrise.innerText = formatTime(daily.sunrise[0]);
            els.sunset.innerText = formatTime(daily.sunset[0]);

            // Sun Position Animation
            updateSunPosition(daily.sunrise[0], daily.sunset[0]);

            // 6. 7-Day Forecast
            renderDaily(daily);

            // Re-init Icons
            if (window.lucide) lucide.createIcons();
        }

        function renderHourly(hourly, currentTimeStr) {
            const currentHourIndex = hourly.time.findIndex(t => t >= currentTimeStr) || 0;
            const next24 = hourly.time.slice(currentHourIndex, currentHourIndex + 24);
            const temps = hourly.temperature_2m.slice(currentHourIndex, currentHourIndex + 24);
            const codes = hourly.weather_code.slice(currentHourIndex, currentHourIndex + 24);

            // Scroll Elements
            let html = '';
            next24.forEach((t, i) => {
                const hour = new Date(t).getHours();
                const ampm = hour >= 12 ? 'PM' : 'AM';
                const h12 = hour % 12 || 12;
                const iconName = getWmoInfo(codes[i]).icon;
                
                html += `
                    <div class="flex flex-col items-center gap-2 min-w-[50px]">
                        <span class="text-xs text-white/50">${h12}${ampm}</span>
                        <i data-lucide="${iconName}" class="w-5 h-5 text-white/80"></i>
                        <span class="text-sm font-bold">${Math.round(temps[i])}°</span>
                    </div>
                `;
            });
            els.hourlyScroll.innerHTML = html;

            // SVG Graph
            if (temps.length > 0) {
                const min = Math.min(...temps) - 2;
                const max = Math.max(...temps) + 2;
                const range = max - min;
                const width = 1000; // virtual width
                const height = 100; // virtual height
                const step = width / (temps.length - 1);

                let pathD = `M0,${height} `; // Start bottom left
                
                temps.forEach((t, i) => {
                    const x = i * step;
                    const y = height - ((t - min) / range) * height;
                    pathD += `L${x},${y} `;
                });

                pathD += `L${width},${height} Z`; // Close path

                // Gradient Stroke Logic not fully supported in simple path d, so we use fill with opacity
                els.graph.innerHTML = `
                    <defs>
                        <linearGradient id="graphGradient" x1="0" x2="0" y1="0" y2="1">
                            <stop offset="0%" stop-color="rgba(255, 255, 255, 0.4)" />
                            <stop offset="100%" stop-color="rgba(255, 255, 255, 0)" />
                        </linearGradient>
                    </defs>
                    <path d="${pathD}" fill="url(#graphGradient)" stroke="rgba(255,255,255,0.6)" stroke-width="2" vector-effect="non-scaling-stroke"/>
                `;
            }
        }

        function renderDaily(daily) {
            let html = '';
            for(let i=1; i<daily.time.length; i++) { // Start from tomorrow
                const dayName = getDayName(daily.time[i]);
                const min = Math.round(daily.temperature_2m_min[i]);
                const max = Math.round(daily.temperature_2m_max[i]);
                const code = daily.weather_code[i];
                const info = getWmoInfo(code);

                // Progress Bar for temp range
                const rangeTotal = 40; // Assume -10 to 30 range generally
                const leftPos = ((min + 10) / rangeTotal) * 100;
                const width = ((max - min) / rangeTotal) * 100;

                html += `
                    <div class="grid grid-cols-[50px_1fr_1fr] items-center gap-4 py-2 border-b border-white/5 last:border-0 hover:bg-white/5 transition-colors rounded-lg px-2">
                        <span class="text-sm font-medium text-white/80">${dayName}</span>
                        <div class="flex items-center gap-2">
                            <i data-lucide="${info.icon}" class="w-5 h-5 text-white/70"></i>
                            <span class="text-xs text-white/50 hidden sm:block">${info.desc}</span>
                        </div>
                        <div class="flex items-center gap-3 justify-end w-full">
                            <span class="text-xs text-white/60 w-6 text-right">${min}°</span>
                            <div class="w-20 h-1.5 bg-white/10 rounded-full relative overflow-hidden">
                                <div class="absolute h-full rounded-full bg-gradient-to-r from-blue-400 to-pink-400 opacity-80" 
                                     style="left: ${Math.max(0, leftPos)}%; width: ${Math.max(10, width)}%"></div>
                            </div>
                            <span class="text-xs font-bold w-6">${max}°</span>
                        </div>
                    </div>
                `;
            }
            els.dailyContainer.innerHTML = html;
        }

        function updateSunPosition(sunriseStr, sunsetStr) {
            const now = new Date().getTime();
            const rise = new Date(sunriseStr).getTime();
            const set = new Date(sunsetStr).getTime();
            
            let pct = 0;
            if (now > rise && now < set) {
                pct = (now - rise) / (set - rise);
            } else if (now >= set) {
                pct = 1;
            }

            // Map 0-1 to SVG Path coordinates (quadratic bezier approx)
            // Path is M10,80 Q100,10 190,80
            // Simple interpolation for x: 10 to 190
            const x = 10 + (pct * 180);
            
            // For Y, we approximate the arc (parabola)
            // y = 4*h*(x/w)*(1-x/w) inverted? simpler: use sin
            // 80 (bottom) -> 10 (top) -> 80 (bottom)
            // Using a simple sin wave for height based on pct
            const y = 80 - (Math.sin(pct * Math.PI) * 70);

            els.sunPos.setAttribute('cx', x);
            els.sunPos.setAttribute('cy', y);

            // Change sun color if night
            if (now < rise || now > set) {
                els.sunPos.setAttribute('fill', '#94a3b8'); // Moon color
                els.sunPos.setAttribute('class', '');
            } else {
                els.sunPos.setAttribute('fill', '#fbbf24');
                els.sunPos.setAttribute('class', 'shadow-[0_0_10px_#fbbf24]');
            }
        }

        // --- SEARCH LOGIC ---
        function toggleSearch() {
            els.searchOverlay.classList.toggle('translate-y-full');
            if (!els.searchOverlay.classList.contains('translate-y-full')) {
                els.searchInput.focus();
            }
        }

        async function handleSearch(e) {
            e.preventDefault();
            const query = els.searchInput.value;
            if (!query) return;

            // Geocoding API
            try {
                const res = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=1&language=en&format=json`);
                const data = await res.json();
                
                if (data.results && data.results.length > 0) {
                    const loc = data.results[0];
                    state.lat = loc.latitude;
                    state.lon = loc.longitude;
                    state.city = loc.name;
                    
                    toggleSearch();
                    els.searchInput.value = '';
                    fetchWeather(); // Refresh
                } else {
                    alert("City not found.");
                }
            } catch (err) {
                alert("Search failed.");
            }
        }

        // --- INIT ---
        if (window.lucide) {
            lucide.createIcons();
        }
        fetchWeather(); // Initial Load (Pretoria)

    </script>
</body>
</html>
